<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Static indices for speedy array-based algorithms</title>
    <link rel="stylesheet" href="../css/default.css">
  </head>
  <body>
    <div id="main">
      <div id="header">
        <div id="navigation">
          <a class="btn" href="../">Home</a>
          <a class="btn" href="../posts">Posts</a>
          <a class="btn" href="../projects">Projects</a>
          <a class="btn" href="../gallery">Gallery</a>
          <a class="btn" href="../resume.html">Resume</a>
          <a class="btn rss" href="../feed.xml">RSS</a>
        </div>
        <div id="title">
          <h1>Static indices for speedy array-based algorithms</h1>
        </div>
      </div>
      <div id="content">
        <div class="info">
  Posted on December 21, 2014
  
    by Mike Ledger
  
</div>

<p><code>GHC.TypeLits</code> gives us some very powerful type-level functionality (with some caveats that will hopefully be worked out in future) that has not yet seen very widespread use. With some mildly ugly leg-work, I’ve made a small library that provides a n-dimensional statically bounded index type, and associated functions for their application with as minimal overhead as possible.</p>
<h2 id="motivation">Motivation</h2>
<p>Making <a href="http://quasimal.com/projects/plissken.html">plissken</a>, I was unhappy with the state of linear algebra libraries on Hackage. The venerable <a href="http://hackage.haskell.org/package/hmatrix">hmatrix</a> is excellent - once your input sizes outweigh the constant factors involved. For the matrices that my game engine lived and survived on – 4x4 matrices and 4-vectors – hmatrix was easily outperformed in simple 4x4 matrix multiplication by <a href="http://hackage.haskell.org/package/linear">linear</a>, which is a naiive Haskell implementation of the sort of “small” linear algebra that I need here. I ended up using hmatrix though, since it being built on <code>Storable</code> made for very easy interaction with OpenGL.</p>
<p>A trick I found in order to inline away “static recursion” was to abstract the use of the recursion parameter into a typeclass whose function is inlined. So long as you remember the all-powerful <code>-O2</code> switch, GHC will happily inline away every recursive call, which will hopefully give way to further compile-time evaluation.</p>
<p>Here’s a little demonstration of such a class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE Undecidableinstances #-}</span> <span class="co">-- our use of this should be fine.</span>
<span class="kw">module</span> <span class="dt">Playaround</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Peano</span> <span class="fu">|</span> <span class="dt">Zero</span>

<span class="kw">class</span> <span class="dt">For</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span>
<span class="ot">  for ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> m ()) <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()

<span class="kw">instance</span> <span class="dt">For</span> <span class="dt">Zero</span> <span class="kw">where</span>
  <span class="ot">{-# INLINE for #-}</span>
  for _ _ acc <span class="fu">=</span> acc

<span class="kw">instance</span> (<span class="dt">KnownNat</span> (<span class="dv">1</span><span class="fu">+</span><span class="dt">FromPeano</span> n), <span class="dt">For</span> n) <span class="ot">=&gt;</span> <span class="dt">For</span> (<span class="dt">Succ</span> n) <span class="kw">where</span>
  <span class="ot">{-# INLINE for #-}</span>
  for p f acc <span class="fu">=</span> for (next p) f (acc <span class="fu">*&gt;</span> f (peanoVal p))

<span class="ot">next ::</span> <span class="dt">Proxy</span> (<span class="dt">Succ</span> n) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n
next _ <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="kw">type</span> family <span class="dt">FromPeano</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">FromPeano</span> <span class="dt">Zero</span>     <span class="fu">=</span> <span class="dv">0</span>
  <span class="dt">FromPeano</span> (<span class="dt">Succ</span> n) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dt">FromPeano</span> n

<span class="kw">type</span> family <span class="dt">ToPeano</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span>
  <span class="dt">ToPeano</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span>
  <span class="dt">ToPeano</span> n <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">ToPeano</span> (n<span class="fu">-</span><span class="dv">1</span>))

<span class="ot">fromPeano ::</span> <span class="dt">Proxy</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">FromPeano</span> n)
fromPeano _ <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">toPeano ::</span> <span class="dt">Proxy</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">ToPeano</span> n)
toPeano _ <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">peanoVal ::</span> <span class="dt">KnownNat</span> (<span class="dt">FromPeano</span> n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>
peanoVal <span class="fu">=</span> fromInteger <span class="fu">.</span> natVal <span class="fu">.</span> fromPeano</code></pre></div>
<p>That’s pretty gross. We can improve it by wrapping it in a small helper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">niceFor ::</span> (<span class="dt">For</span> (<span class="dt">ToPeano</span> n), <span class="dt">Applicative</span> m)
        <span class="ot">=&gt;</span> <span class="dt">Proxy</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> m ()) <span class="ot">-&gt;</span> m ()
niceFor p f <span class="fu">=</span> for (toPeano p) f (pure ())</code></pre></div>
<p>Unfortunately GHC doesn’t see as we can intuitively, that since all <code>Nat</code> has an instance for <code>ToPeano</code>, <code>For</code> has the instance <code>For (ToPeano (n :: Nat))</code>, so we have to add that constraint.</p>
<p>Let’s try it out:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Playaround</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Mutable</span> <span class="kw">as</span> <span class="dt">VM</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  vect <span class="ot">&lt;-</span> M.new <span class="dv">16</span>
  niceFor (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">15</span>) <span class="fu">$</span> \ix <span class="ot">-&gt;</span> 
    M.write vect ix ix</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghc-core</span> Main.hs
    <span class="kw">-dsuppress-idinfo</span> \
    -dsuppress-coercions \
    -dsuppress-type-applications \
    -dsuppress-uniques \
    -dsuppress-module-prefixes</code></pre></div>
<p>Some scrolling later…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main1 ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>, () <span class="fu">#</span>)
main1 <span class="fu">=</span>
  \ (<span class="ot">eta ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span>
    <span class="kw">case</span> newArray<span class="fu">#</span> <span class="dv">16</span> (uninitialised) (eta <span class="ot">`cast`</span> <span class="fu">...</span>)
    <span class="kw">of</span> _ { (<span class="fu">#</span> ipv, ipv1 <span class="fu">#</span>) <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">15</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">15</span>) ipv <span class="kw">of</span> s'<span class="fu">#</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">14</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">14</span>) s'<span class="fu">#</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">1</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">13</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">13</span>) s'<span class="fu">#</span><span class="dv">1</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">2</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">12</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">12</span>) s'<span class="fu">#</span><span class="dv">2</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">3</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">11</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">11</span>) s'<span class="fu">#</span><span class="dv">3</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">4</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">10</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">10</span>) s'<span class="fu">#</span><span class="dv">4</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">5</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">9</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">9</span>) s'<span class="fu">#</span><span class="dv">5</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">6</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">8</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">8</span>) s'<span class="fu">#</span><span class="dv">6</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">7</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">7</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">7</span>) s'<span class="fu">#</span><span class="dv">7</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">8</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">6</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">6</span>) s'<span class="fu">#</span><span class="dv">8</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">9</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">5</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">5</span>) s'<span class="fu">#</span><span class="dv">9</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">10</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">4</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">4</span>) s'<span class="fu">#</span><span class="dv">10</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">11</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">3</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">3</span>) s'<span class="fu">#</span><span class="dv">11</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">12</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">2</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">2</span>) s'<span class="fu">#</span><span class="dv">12</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">13</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    <span class="kw">case</span> writeArray<span class="fu">#</span> ipv1 <span class="dv">1</span> (<span class="dt">I</span><span class="fu">#</span> <span class="dv">1</span>) s'<span class="fu">#</span><span class="dv">13</span> <span class="kw">of</span> s'<span class="fu">#</span><span class="dv">14</span> { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
    (<span class="fu">#</span> s'<span class="fu">#</span><span class="dv">14</span>, () <span class="fu">#</span>) <span class="ot">`cast`</span> <span class="fu">...</span>
    } } } } } } } } } } } } } } } }</code></pre></div>
<p>Great! The loop is unrolled rather nicely.</p>
<h2 id="enter-indices">Enter <em>indices</em></h2>
<p><code>indices</code> provides a multi-dimensional (<code>Int</code> based) index type, with use for array-heavy code in mind. I hope Soon® to release on Hackage the package <a href="https://github.com/mikeplus64/static">static</a> (patches welcome and appreciated) which provides a <code>ForiegnPtr</code> based array type that leverages <code>indices</code>’s, ahem, indices, just about everywhere.</p>
<p>Indices in <code>indices</code> are these two types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="fu">:.</span> b <span class="fu">=</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">:.</span> b
<span class="kw">data</span> <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Z</span></code></pre></div>
<p>This is similar to the design seen in <a href="https://hackage.haskell.org/package/repa">repa</a>, except the “bound” of an index is its type. That’s crippling for code with arbitrarily-bounded arrays, but very nice otherwise. For instance, an index into a 4x4 matrix is <code>0:.0:.Z :: 4:.4:.Z</code> .</p>
<p>For now, you can use <code>indices</code> for array-based code by leveraging its <code>Ix</code> instance. This is a little confusing due to the design of <code>Ix</code>, but it’s fairly simple: the type is always the upper bound, and zero is always the lower bound, not a value you give. That means that arrays constructed by <code>array (_, _ :: t)</code> are bounded by [0,t). As an aside, I’m leaning towards reworking <code>static</code> to simply use the array types found in <a href="https://hackage.haskell.org/package/arrays">arrays</a> to simplify it greatly into the small linear-algebra package it yearns to be. Input is appreciated here. (At the moment I’m irked at having to store two superfluous lower/upper bounds – linked lists of <code>Int</code> – in the array constructors).</p>
<p>Here’s a demonstration, implementing vector dot product with a static, unrolled loop:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds     #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds     #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="kw">module</span> <span class="dt">MM</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Data.Array.Unboxed</span>
<span class="kw">import </span><span class="dt">Data.Index</span>

<span class="kw">type</span> <span class="dt">Vector</span> m <span class="fu">=</span> <span class="dt">UArray</span> (m<span class="fu">:.</span><span class="dt">Z</span>)

<span class="ot">sizeV ::</span> <span class="dt">Vector</span> m a <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (m<span class="fu">:.</span><span class="dt">Z</span>)
sizeV _ <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">vector ::</span> (<span class="dt">IArray</span> <span class="dt">UArray</span> a, <span class="dt">Dim</span> (m<span class="fu">:.</span><span class="dt">Z</span>)) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> (m<span class="fu">:.</span><span class="dt">Z</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Vector</span> m a
vector b <span class="fu">=</span> listArray (zero, maxBound <span class="ot">`asProxyTypeOf`</span> b)

dot a b <span class="fu">=</span>
  sfoldlRange
    (sizeV a <span class="ot">`asTypeOf`</span> sizeV b)
    (\sum ix <span class="ot">-&gt;</span> sum <span class="fu">+</span> a<span class="fu">!</span>ix <span class="fu">*</span> b<span class="fu">!</span>ix)
    <span class="dv">0</span>

v4 x y z w <span class="fu">=</span> vector (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">4</span><span class="fu">:.</span><span class="dt">Z</span>)) [x,y,z,w]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print (dot (v4 <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) (v4 <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Double</span>)
  print (sum (zipWith (<span class="fu">*</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>])<span class="ot"> ::</span> <span class="dt">Double</span>)</code></pre></div>
<p>Note the slyness in me not writing the type signature to <code>dot</code>… Well, the important thing is that GHC happily infers the type without needing any hints. <em>Right… guys?</em></p>
<p>You can contribute to <code>indices</code> <a href="https://github.com/mikeplus64/indices">on GitHub</a>, find its documentation <a href="https://hackage.haskell.org/package/indices">on Hackage</a>, and install it with <code>cabal</code>.</p>

<br />

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'quasimal';
  (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


      </div>
    </div>
  </body>
</html>
