<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>A look at QuasiQuotation</title>
    <link rel="stylesheet" href="../css/default.css">
  </head>
  <body>
    <div id="main">
      <div id="header">
        <div id="navigation">
          <a class="btn" href="../">Home</a>
          <a class="btn" href="../posts">Posts</a>
          <a class="btn" href="../projects">Projects</a>
          <a class="btn" href="../gallery">Gallery</a>
          <a class="btn" href="../resume.html">Resume</a>
          <a class="btn rss" href="../feed.xml">RSS</a>
        </div>
        <div id="title">
          <h1>A look at QuasiQuotation</h1>
        </div>
      </div>
      <div id="content">
        <div class="info">
  Posted on May 25, 2012
  
    by Mike Ledger
  
</div>

<p>A week or so ago I finished <a href="http://hackage.haskell.org/package/QuasiText">QuasiText</a>, a small Text interpolation library to generate at compile-time expressions with interpolated variables and/or Haskell code.</p>
<h2 id="building-a-quasiquoter">Building a QuasiQuoter</h2>
<p>Trying to figure out how to build a QuasiQuoter wasn’t hard at all. Partly because of the excellent documentation, and partly because of my hard work annoying others in #haskell.</p>
<p>At the core of a TemplateHaskell splice, as far as expressions go, is the <em>Q Exp</em>. A <em>Q Exp</em> can be evaluated at compile time using the splice syntax <em>$(TemplateHaskell functions evaluating to a <em>Q Exp</em> go here)</em>. A QuasiQuoter is simply a function that takes a string and returns a <em>Q Exp</em>, <em>Q Pat</em>, <em>Q Type</em> or <em>Q [Dec]</em>.</p>
<p>For example, to define a nice and silly QuasiQuoter that does nothing but return the string “yeah!!!”, we can do:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="kw">module</span> <span class="dt">SimpleQuoter</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Quote</span> <span class="co">-- gives us QuasiQuoter</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>       <span class="co">-- gives us stuff to return 'Q Exp's.</span>
                                 <span class="co">-- ie. stringL, litE</span>

<span class="ot">silly ::</span> <span class="dt">QuasiQuoter</span>
silly <span class="fu">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="fu">=</span> \_ <span class="ot">-&gt;</span> [<span class="fu">|</span> <span class="st">&quot;yeah!!!&quot;</span> <span class="fu">|</span>] }</code></pre></div>
<p>You will have noticed the use of the big scary <em>[| … |]</em>s. All these are doing in silly’s case is “lifting” the String “yeah!!!” into a <em>Q Exp</em>. For information about lifting, you can look <a href="http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH-Syntax.html">at the docs</a> for the Lift typeclass. (note that <em>[| … |]</em> is syntactic sugar for <em>lift …</em>)</p>
<p>Using the functions given by Language.Haskell.TH for creating Q Exps from fairy dust, if we were at some point feeling unsatisfied by string literals in Haskell, we could define:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">string ::</span> <span class="dt">QuasiQuoter</span>
string <span class="fu">=</span> <span class="dt">QuasiQuoter</span>
    { quoteExp <span class="fu">=</span> litE <span class="fu">.</span> stringL
        <span class="co">-- note that: quoteExp :: String -&gt; Q Exp</span>
        <span class="co">--            stringL :: String -&gt; Lit</span>
        <span class="co">--            litE :: Lit -&gt; Q Exp</span>
        <span class="co">-- so: litE . stringL = \x -&gt; litE (stringL x)</span>
    }</code></pre></div>
<p>Another way of writing it, using lift instead, could be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">string ::</span> <span class="dt">QuasiQuoter</span>
string <span class="fu">=</span> <span class="dt">QuasiQuoter</span>
    { quoteExp <span class="fu">=</span> \s <span class="ot">-&gt;</span> [<span class="fu">|</span> s <span class="fu">|</span>]
      <span class="co">-- OR, with Language.Haskell.TH.Syntax imported: quoteExp = lift</span>
    }</code></pre></div>
<p>For trivial examples like this, it doesn’t matter what “style” you choose.</p>
<p>Lets forget about QuasiQuoters for a moment, and remember that no Haskell tutorial is complete without a fibonacci sequence function. Lets make a compile-time function to return the code to get the nth fibonacci number.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fibs ::</span> [<span class="dt">Integer</span>]
fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)

<span class="ot">fibsQ ::</span> <span class="dt">Q</span> <span class="dt">Exp</span>
fibsQ <span class="fu">=</span> [<span class="fu">|</span> fibs <span class="fu">|</span>]

<span class="ot">fibQ ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
fibQ <span class="fu">=</span> [<span class="fu">|</span> fibs <span class="fu">!!</span> n <span class="fu">|</span>]</code></pre></div>
<p>If we fire up GHCi and type in <em>$(fibQ 10)</em>, we’ll get the 10th fibonacci number. All we’re really doing is lifting the expression <em>fibs !! n</em> to be a <em>Q Exp</em>, then evaluating this <em>Q Exp</em> with <em> $(…) </em>.</p>
<p>Now, back to the thing. At the time I wrote QuasiText, I wanted some nice Text (from Data.Text, the string type all the cool people use) interpolation without any weird unpacking and packing done at runtime (Text recently got “real” Text literals, which makes me feel very awkward about having to pack Strings -&gt; Text).</p>
<p>Lets say that we want the DSL to look like: “[intp|text goes here $funs $go $here |]”, to implement this, we should first make a parser to translate strings into our abstract format.</p>
<h2 id="building-the-parser-qformat.hs">Building the parser: QFormat.hs</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings, TemplateHaskell #-}</span>
<span class="kw">module</span> <span class="dt">QFormat</span> <span class="kw">where</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import </span><span class="dt">Data.Attoparsec.Text</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Syntax</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Quote</span>

<span class="kw">type</span> <span class="dt">Chunk</span> <span class="fu">=</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">String</span>
<span class="co">-- a chunk is either just raw Text, or the String name of a variable</span>

<span class="ot">makeChunks ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Chunk</span>]
makeChunks ts <span class="fu">=</span> <span class="kw">case</span> parseOnly parser ts <span class="kw">of</span>
    <span class="dt">Right</span> x <span class="ot">-&gt;</span> x
    _       <span class="ot">-&gt;</span> error <span class="st">&quot;malformed text&quot;</span>
  <span class="kw">where</span>
    parser <span class="fu">=</span> <span class="kw">do</span>
        res <span class="ot">&lt;-</span> loop []
        return [ rs <span class="fu">|</span> rs <span class="ot">&lt;-</span> res, rs <span class="fu">/=</span> <span class="dt">Left</span> <span class="st">&quot;&quot;</span>, rs <span class="fu">/=</span> <span class="dt">Right</span> <span class="st">&quot;&quot;</span>]

    variable <span class="fu">=</span> <span class="kw">do</span>
        char <span class="ch">'$'</span>
        name <span class="ot">&lt;-</span> takeTill (notInClass <span class="st">&quot;a-zA-Z0-9_&quot;</span>)
        return (<span class="dt">Right</span> (T.unpack name))

    loop xs <span class="fu">=</span> <span class="kw">do</span>
        text <span class="ot">&lt;-</span> takeTill (<span class="fu">==</span> <span class="ch">'$'</span>)
        var  <span class="ot">&lt;-</span> choice [variable, fmap <span class="dt">Left</span> takeText]
        end  <span class="ot">&lt;-</span> atEnd
        <span class="kw">if</span> end
            <span class="kw">then</span> return <span class="fu">$</span> reverse (var <span class="fu">:</span> <span class="dt">Left</span> text <span class="fu">:</span> xs)
            <span class="kw">else</span> loop (var <span class="fu">:</span> <span class="dt">Left</span> text <span class="fu">:</span> xs)</code></pre></div>
<p>From this, we can parse Text into [Chunk]:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> makeChunks <span class="st">&quot;a b c foobar $doobar $goobar. $asdf&quot;</span>
[<span class="dt">Left</span> <span class="st">&quot;a b c foobar &quot;</span>,<span class="dt">Right</span> <span class="st">&quot;doobar&quot;</span>,<span class="dt">Left</span> <span class="st">&quot; &quot;</span>,<span class="dt">Right</span> <span class="st">&quot;goobar&quot;</span>,<span class="dt">Left</span> <span class="st">&quot;. &quot;</span>,<span class="dt">Right</span> <span class="st">&quot;asdf&quot;</span>]</code></pre></div>
<p>But, what we obviously want is for all the <em>Left xs</em> to be turned into <em>Text</em>, and then all the <em>Right ys</em> to be turned into their respective definitions in the given source file, and then for the result to be folded together with <em>T.append</em> (although in actual code I tend to use <em>Data.Monoid</em>’s (&lt;&gt;)).</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>The above sounds like just the job for a QuasiQuoter! Lets give it a try. For convenience I will also define an instance for <em>Lift Text</em>, allowing us to lift <em>Text</em> values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Text</span> <span class="kw">where</span>
    lift t <span class="fu">=</span> litE (stringL (unpack t))

<span class="ot">format ::</span> <span class="dt">QuasiQuoter</span>
format <span class="fu">=</span> <span class="dt">QuasiQuoter</span>
    { quoteExp <span class="fu">=</span> \s <span class="ot">-&gt;</span>
        <span class="kw">let</span> chunks       <span class="fu">=</span> makeChunks (T.pack s)
            liftedChunks <span class="fu">=</span> flip map chunks <span class="fu">$</span> \c <span class="ot">-&gt;</span> <span class="kw">case</span> c <span class="kw">of</span>
                <span class="dt">Left</span>  t <span class="ot">-&gt;</span> [<span class="fu">|</span> t <span class="fu">|</span>]           <span class="co">-- lift raw text</span>
                <span class="dt">Right</span> v <span class="ot">-&gt;</span> global (mkName v) <span class="co">-- get a global Name from the name given</span>

        <span class="co">-- and now to fold it all together ... </span>
        <span class="kw">in</span> foldr (\l r <span class="ot">-&gt;</span> appE [<span class="fu">|</span> T.append <span class="fu">|</span>] l <span class="ot">`appE`</span> r) [<span class="fu">|</span> T.empty <span class="fu">|</span>] liftedChunks

        <span class="co">-- note that: appE :: Q Exp -&gt; Q Exp -&gt; Q Exp; it acts as function application for Q Exps</span>
        <span class="co">--            [| T.append |] is the Q Exp form of T.append</span>
    }</code></pre></div>
<p>And now the moments of truth: does it work? Let us consult GHCi for the answer. I set <em>-ddump-splices</em> to show the intermediate splices that GHC generates. Also note that it needs <em>OverloadedStrings</em> to work for it to evaluate to <em>Text</em> at all.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">QFormat</span><span class="fu">&gt;</span> <span class="fu">:</span>l QFormat.hs
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span> 
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XQuasiQuotes</span>
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span>ddump<span class="fu">-</span>splices
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">&gt;</span> <span class="kw">let</span> place <span class="fu">=</span> <span class="st">&quot;World&quot;</span> <span class="kw">in</span> [format<span class="fu">|</span><span class="dt">Hello</span> <span class="fu">$</span>place<span class="fu">!|</span>]
<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">18</span><span class="fu">:</span><span class="dv">24</span><span class="fu">-</span><span class="dv">46</span><span class="fu">:</span> <span class="dt">Splicing</span> expression
    <span class="st">&quot;Hello $place!&quot;</span>
  <span class="fu">======&gt;</span>
    T.append <span class="st">&quot;Hello &quot;</span> (T.append place (T.append <span class="st">&quot;!&quot;</span> T.empty))
<span class="st">&quot;Hello World!&quot;</span>
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">&gt;</span> <span class="co">-- excellent!</span>
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">&gt;</span> <span class="fu">:</span>{ 
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">|</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="st">&quot;yeah&quot;</span> 
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">|</span>     b <span class="fu">=</span> <span class="st">&quot;maybe&quot;</span> 
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">|</span>     person <span class="fu">=</span> <span class="st">&quot;jarjar&quot;</span> 
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">|</span>     desc   <span class="fu">=</span> <span class="st">&quot;best character&quot;</span> 
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">|</span> <span class="kw">in</span> [format<span class="fu">|$</span>person was <span class="fu">$</span>desc, <span class="fu">$</span>a, <span class="fu">$</span>b, ok maybe not<span class="fu">|</span>]
<span class="fu">*</span><span class="dt">QFormat</span><span class="fu">|</span> <span class="fu">:</span>}
<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">41</span><span class="fu">:</span><span class="dv">4</span><span class="fu">-</span><span class="dv">52</span><span class="fu">:</span> <span class="dt">Splicing</span> expression
    <span class="st">&quot;$person was $desc, $a, $b, ok maybe not&quot;</span>
  <span class="fu">======&gt;</span>
    T.append
      person
      (T.append
         <span class="st">&quot; was &quot;</span>
         (T.append
            desc
            (T.append
               <span class="st">&quot;, &quot;</span>
               (T.append
                  a
                  (T.append
                     <span class="st">&quot;, &quot;</span> (T.append b (T.append <span class="st">&quot;, ok maybe not&quot;</span> T.empty)))))))
<span class="st">&quot;jarjar was best character, yeah, maybe, ok maybe not&quot;</span></code></pre></div>
<p>So there we have it! I hope you found this little tutorial useful and/or enlightening. Making it certainly was a learning process in and of itself. <a href="http://hackage.haskell.org/package/QuasiText">My actual library</a>, which is frighteningly similar to the code we’ve hacked up here, although you can embed arbitrary Haskell expressions (leveraging the power of <em>haskell-src-meta</em>) into <em>QuasiText</em> interpolated strings.</p>
<h2 id="but-wait">But wait!</h2>
<p>Antoine Latter in the comments section pointed out: “You’ll probably do less allocation at run-time if you use the ‘Data.Text.concat’ function.” I concur with this statement.</p>
<p>So, lets refactor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">format ::</span> <span class="dt">QuasiQuoter</span>
format <span class="fu">=</span> <span class="dt">QuasiQuoter</span>
    { quoteExp <span class="fu">=</span> \s <span class="ot">-&gt;</span>
        <span class="kw">let</span> chunks       <span class="fu">=</span> makeChunks (T.pack s)
            liftedChunks <span class="fu">=</span> flip map chunks <span class="fu">$</span> \c <span class="ot">-&gt;</span> <span class="kw">case</span> c <span class="kw">of</span>
                <span class="dt">Left</span>  t <span class="ot">-&gt;</span> [<span class="fu">|</span> t <span class="fu">|</span>]           <span class="co">-- lift raw text</span>
                <span class="dt">Right</span> v <span class="ot">-&gt;</span> global (mkName v) <span class="co">-- get a global Name from the name given</span>
        <span class="kw">in</span> appE [<span class="fu">|</span> T.concat <span class="fu">|</span>] (listE liftedChunks)
        <span class="co">-- note that listE :: [Q Exp] -&gt; Q Exp</span>
    }</code></pre></div>
<p>This is decidedly simpler than the example above, but for the sake of illustrating how to use TemplateHaskell, I’ll keep the former examples.</p>

<br />

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'quasimal';
  (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


      </div>
    </div>
  </body>
</html>
